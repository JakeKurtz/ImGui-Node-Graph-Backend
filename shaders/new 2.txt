

Render Algorithm

Render depth pass

For all objects
	render into depth buffer

For each deffered material

	get all objects with this material and store them in M
	
	// Geometry Pass

	mat.gbuffer.bind(film_w, film_h);
	
	mat.geom_pass_shader.enable();
	For each object in M
		obj.send_uniforms(mat.geom_pass_shader);
		obj.draw();
	
	mat.gbuffer.unbind();
	
	// Lighting Pass
	
	this->fbo.bind(film_w, film_h);
	
	mat.light_pass_shader.enable();
	mat.send_uniforms();
	For each light
		light.send_uniforms(mat.light_pass_shader);
	draw_screen();
	
	this->fbo.unbind();

this->fbo.bind(film_w, film_h);	

For each forward material

	mat.light_pass_shader.enable();

	For each object in M
		obj.send_uniforms(mat.light_pass_shader);
		
this->fbo.unbind();
	
	
	
	
Node Graph editor:
	edit node graph
	uses Node Graph Engine
	
Node Graph engine:
	builds Material object
	
	two parts for code
		1. lighting code
			diffuse
			glossy
			glass
			mix
			add
		2. code that gets loaded into lighting code parameters

BSDF
	gbuffer layout
	geometry shader
	lighting code to inject into either the forward or deffered lighting path
	
Material
	contains material shader code, shader uniforms, bsdfs
	decides lighting path
	
Material instance
	parent id;
	uniforms;
	
	
Node Edit Window
	Edits node graph
	
Node Graph Engine
	Evaluates graph
	
Shader Graph Engine
	Builds shader code
	Gathers uniforms  
	
	
//  #version 330 core
//  layout locations
/*
	in vec2 in_texcoord;
	in vec3 in_fragpos;
	in vec3 in_normal;
	in mat3 in_TBN;
*/
//  inject graph uniforms here
/*
	void main() {
		gPosition = in_fragpos;
*/
//      inject graph code here
//  }

//  #version 330 core
/*
	out vec4 out_fragcolor;
	in vec2 in_texcoord;
*/
//  uniforms
//  inject graph uniforms here
//  shader code
/*
	void main() {
		gPosition = in_fragpos;
*/
//      inject graph code here
//  }